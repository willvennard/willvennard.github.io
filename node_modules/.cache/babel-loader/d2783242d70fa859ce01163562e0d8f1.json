{"ast":null,"code":"import * as d3 from \"d3\";\n\nclass SnakeGame {\n  constructor() {\n    this.playing = false;\n    this.count = 0;\n    this.foodCord = [];\n    this.headCord = [];\n    this.snakeBody = [];\n    this.foodOnBoard = false;\n    this.score = 0;\n    this.speed = 200;\n    this.snakeTail = [];\n    this.snakeDirection = 'ArrowRight';\n    this.lastSnakeDirection = ''; // this.board = {\n    //   width: 300,\n    //   height: 300\n    // }\n\n    const segmentDim = 10;\n    const boardWidth = 300;\n    const boardHeight = 300;\n    const segmentRadius = 5;\n  } // Might be a better way to do this.\n  // put into another class and simply reset?\n\n\n  initGame() {\n    d3.select('#score').style(\"display\", \"block\");\n    d3.select('#start-game').style(\"display\", \"none\");\n    d3.select('#board').remove();\n    d3.select('#end-text').remove();\n    this.headCord = [0, 0];\n    this.snakeBody = [];\n    this.score = 0;\n    this.speed = 200;\n    this.bombCount = 0;\n    this.snakeDirection = 'ArrowRight';\n    this.snakeBody.push(this.headCord);\n    this.playing = true;\n    d3.select('#game-space').append('svg').attr('id', 'board').attr('width', this.boardWidth).attr('height', this.boardHeight).append('rect').attr('class', 'snake head').attr(\"id\", \"segment\" + (this.snakeBody.length - 1)).attr('width', this.segmentDim).attr('height', this.segmentDim).attr('x', this.headCord[0]).attr('y', this.headCord[1]).attr(\"ry\", this.segmentRadius).attr(\"rx\", this.segmentRadius).attr('fill', 'red'); // do this with d3\n\n    d3.select('#score-count').text(this.score);\n    this.spawnFood();\n    this.gameTick();\n  }\n\n  randomBoardCord() {\n    let segDim = this.segmentDim;\n    let x = Math.round(Math.random() * this.boardWidth / segDim) * segDim - segDim;\n    let y = Math.round(Math.random() * this.boardHeight / segDim) * segDim - segDim; // keep food on map\n\n    if (x > this.boardWidth) {\n      x = this.boardWidth - segDim;\n    }\n\n    if (x < 0) {\n      x = 0;\n    }\n\n    if (y > this.boardHeight) {\n      y = this.boardHeight - segDim;\n    }\n\n    if (y < 0) {\n      y = 0;\n    }\n\n    return [x, y];\n  }\n\n  spawnFood() {\n    this.foodCord = this.randomBoardCord();\n    d3.select('#board').append('rect').attr(\"id\", \"food\").attr(\"width\", this.segmentDim).attr(\"height\", this.segmentDim).attr(\"x\", this.foodCord[0]).attr(\"y\", this.foodCord[1]).attr(\"ry\", this.segmentRadius).attr(\"rx\", this.segmentRadius).attr(\"fill\", \"limegreen\").style(\"opacity\", 0).transition().duration(1000).style(\"opacity\", 1);\n    this.foodOnBoard = true;\n  }\n\n  moveSnake(index, cord) {\n    d3.select('#segment' + index).attr(\"x\", cord[0]).attr(\"y\", cord[1]);\n\n    if (+index !== this.snakeBody.length - 1) {\n      let nextIdx = index + 1;\n      let oldCord = this.snakeBody[index];\n      moveSnake(nextIdx, oldCord);\n    }\n\n    this.snakeBody[index] = [cord[0], cord[1]];\n  }\n\n  gameLost() {\n    clearTimeout(gameTicker);\n    console.log('Game over.');\n\n    if (!this.playing) {\n      return;\n    }\n\n    this.playing = false; // remove old stuff and show game over\n\n    d3.select('#food').transition().duration(1000).style(\"opacity\", 0).remove();\n    d3.selectAll(\".snake\").transition().duration(1000).style(\"opacity\", 0).remove();\n    d3.select('#bomb-text').remove();\n    d3.select('#bomb').transition().duration(1000).style(\"opacity\", 0).remove();\n    d3.select('#end-text').remove();\n    d3.select('#game-space').append('h3').text('GAME OVER').attr('id', 'end-text').style(\"opacity\", 0).transition().duration(1000).style(\"opacity\", 1);\n    d3.select('#start-game').style(\"display\", \"block\");\n  }\n\n  gameTick() {\n    this.count++;\n\n    if (this.snakeDirection === 'ArrowLeft') {\n      this.headCord[0] = this.headCord[0] - this.segmentDim;\n    } else if (snakeDirection === 'ArrowUp') {\n      this.headCord[1] = this.headCord[1] - this.segmentDim;\n    } else if (snakeDirection === 'ArrowRight') {\n      this.headCord[0] = this.headCord[0] + this.segmentDim;\n    } else if (snakeDirection === 'ArrowDown') {\n      this.headCord[1] = this.headCord[1] + this.segmentDim;\n    } //headCord = [0,0]\n\n\n    this.snakeTail = [this.snakeBody[this.snakeBody.length - 1][0], this.snakeBody[this.snakeBody.length - 1][1]];\n    moveSnake(0, this.headCord);\n\n    if (this.foodCord.length > 0) {\n      if (this.foodCord[0] === this.headCord[0] && this.foodCord[1] === this.headCord[1]) {\n        console.warn('FOOD EATEN!!!');\n        this.score++;\n\n        if (this.speed > 100) {\n          this.speed = this.speed - 25;\n        }\n\n        d3.select(\"#score-count\").text(this.score);\n        d3.select('#food').remove();\n        this.foodOnBoard = false;\n        this.snakeBody.push(this.snakeTail);\n        d3.select('#board').append('rect').attr(\"class\", \"snake\").attr(\"id\", \"segment\" + (this.snakeBody.length - 1)).attr(\"width\", this.segmentDim).attr(\"height\", this.segmentDim).attr(\"x\", this.snakeTail[0]).attr(\"y\", this.snakeTail[1]).attr(\"ry\", this.segmentRadius).attr(\"rx\", this.segmentRadius).attr(\"fill\", \"purple\");\n      }\n    }\n\n    if (this.count % 5 === 0 && !this.foodOnBoard) {\n      this.spawnFood();\n    } // put bomb stuff in seperate function\n\n\n    let snakeBombs = new SnakeBombs();\n    console.warn(\"DEBUG DEBUG game tick: snakeBombs =\", snakeBombs); // bomb tick\n\n    if (this.liveBomb) {\n      console.log('This bomb is ticking...', bombCount); // count down in seconds\n\n      let slowCount = Math.round(1000 / this.speed);\n\n      if (+this.bombCount > 0 && this.count % slowCount === 1) {\n        this.bombCount = this.bombCount - 1;\n        d3.select('#bomb-text').text(this.bombCount);\n      } else if (this.bombCount <= 0) {\n        // boom\n        console.log(\"Boom!\");\n        this.bombGoesBoom();\n      }\n    } // spawn bomb\n\n\n    if (this.score > 0 && this.count % 10 === 0 && !this.liveBomb) {\n      this.spawnBomb();\n    } // losing conditions\n\n\n    if (this.headCord[0] >= this.boardWidth || this.headCord[0] < 0 // off the sides \n    || this.headCord[1] < 0 || this.headCord[1] >= this.boardHeight) {\n      // off the top or bottom\n      console.log('Snakes out of the box!');\n      this.gameLost();\n      return;\n    }\n\n    for (let segment of this.snakeBody) {\n      if (this.snakeBody.indexOf(segment) === 0) {\n        continue;\n      }\n\n      if (this.headCord[0] === segment[0] && this.headCord[1] === segment[1]) {\n        console.log('You bit your own tail...');\n        this.gameLost();\n        return;\n      }\n    }\n\n    let that = this;\n    gameTicker = setTimeout(function () {\n      that.gameTick();\n    }, that.speed);\n  }\n\n}\n\nclass SnakeBombs extends SnakeGame {\n  constructor() {\n    this.bombCord = [];\n    this.liveBomb = false;\n    this.bombCount = 0;\n    this.explosionRadius = 2;\n  }\n\n  spawnBomb() {\n    this.bombCord = randomBoardCord();\n    this.bombCount = 5;\n    d3.select('#board').append('rect').attr(\"id\", \"bomb\").attr(\"width\", this.segmentDim).attr(\"height\", this.segmentDim).attr(\"x\", this.bombCord[0]).attr(\"y\", this.bombCord[1]).attr(\"ry\", this.segmentRadius).attr(\"rx\", this.segmentRadius).attr(\"fill\", \"orange\").style(\"opacity\", 0).attr(\"stroke\", \"red\").transition().duration(1000).style(\"opacity\", 1);\n    d3.select('#board').append('text').attr('id', 'bomb-text').text(this.bombCount).style('fill', 'black').style('font-size', '65%').attr(\"transform\", \"translate(\" + (this.bombCord[0] + this.segmentDim / 4) + \",\" + (this.bombCord[1] + this.segmentDim - 1) + \")\");\n    this.liveBomb = true;\n  }\n\n  bombGoesBoom() {\n    let colorScale = d3.scaleLinear().domain([0, this.bombRadius]).range(['red', 'yellow']);\n    let explosionArea = [];\n\n    for (let i = 1; i <= this.bombRadius; i++) {\n      let start = this.bombCord;\n\n      for (let xDim = -i; xDim <= i; xDim++) {\n        for (let yDim = -i; yDim <= i; yDim++) {\n          let newX = start[0] + xDim * this.segmentDim;\n          let newY = start[1] + yDim * this.segmentDim;\n          let newCord = [newX, newY];\n\n          if (!explosionArea.includes(newCord)) {\n            explosionArea.push(newCord);\n          }\n        }\n      }\n    }\n\n    for (let block of explosionArea) {\n      // distance in block units\n      let distance = distanceBetweenPoints(this.bombCord, block) / segmentDim;\n      d3.select('#board').append('rect').attr(\"class\", \"boom\").attr(\"width\", this.segmentDim).attr(\"height\", this.segmentDim).attr(\"x\", block[0]).attr(\"y\", block[1]).attr(\"ry\", this.segmentRadius).attr(\"rx\", this.segmentRadius).attr(\"fill\", colorScale(distance)).style(\"opacity\", 1).attr(\"stroke\", \"red\").transition().duration(1500).style(\"opacity\", 0).attr(\"fill\", \"blue\").attr(\"width\", 1).attr(\"height\", 1).remove();\n    }\n\n    d3.select('#bomb-text').remove();\n    d3.select('#bomb').transition().duration(1500).style(\"opacity\", 0).remove();\n    this.bombCount = 0;\n    this.liveBomb = false;\n    this.isHeadInExplosion();\n  }\n\n  isHeadInExplosion() {\n    let bombR = this.bombRadius;\n    let segDim = this.segmentDim;\n    let explosionXRange = [this.bombCord[0] - segDim * bombR, this.bombCord[0] + segDim * bombR];\n    let explosionYRange = [this.bombCord[1] - segDim * bombR, this.bombCord[1] + segDim * bombR];\n    let detectX = this.headCord[0] >= explosionXRange[0] && this.headCord[0] <= explosionXRange[1];\n    let detectY = this.headCord[1] >= explosionYRange[0] && this.headCord[1] <= explosionYRange[1];\n\n    if (detectX && detectY) {\n      console.log(\"Ouch, killed by a bomb...\");\n      this.gameLost();\n    }\n  }\n\n}\n\nfunction distanceBetweenPoints(pointA, pointB) {\n  let x0 = pointA[0];\n  let x1 = pointB[0];\n  let y0 = pointA[1];\n  let y1 = pointB[1];\n  let x = Math.pow(x1 - x0, 2);\n  let y = Math.pow(y1 - y0, 2);\n  let distance = Math.pow(x + y, 0.5);\n  return distance;\n} // snake\n\n\nlet gameTicker;\nlet count = 0;\nconst segmentDim = 10;\nconst boardWidth = 300;\nconst boardHeight = 300;\nconst segmentRadius = 5;\nlet foodCord = [];\nlet headCord = [];\nlet snakeBody = [];\nlet foodOnBoard = false;\nlet score = 0;\nlet speed = 200;\nlet snakeTail = [];\nlet snakeDirection = 'ArrowRight';\nlet lastSnakeDirection = ''; // bomb stuff\n\nlet bombCord = [];\nlet liveBomb = false;\nlet bombCount = 0;\nlet bombRadius = 3;\nexport function startSnakeGame() {\n  console.log('startSnakeGame: Start game!!');\n  initGame();\n}\ndocument.addEventListener('keydown', event => {\n  if (event.key === 'ArrowLeft' || event.key === 'ArrowUp' || event.key === 'ArrowRight' || event.key === 'ArrowDown') {\n    event.preventDefault();\n\n    if (snakeDirection === 'ArrowLeft' && event.key === 'ArrowRight') {\n      return;\n    }\n\n    if (snakeDirection === 'ArrowRight' && event.key === 'ArrowLeft') {\n      return;\n    }\n\n    if (snakeDirection === 'ArrowUp' && event.key === 'ArrowDown') {\n      return;\n    }\n\n    if (snakeDirection === 'ArrowDown' && event.key === 'ArrowUp') {\n      return;\n    }\n\n    snakeDirection = event.key;\n  }\n});\n\nfunction initGame() {\n  d3.select('#score').style(\"display\", \"block\");\n  d3.select('#start-game').style(\"display\", \"none\");\n  d3.select('#board').remove();\n  d3.select('#end-text').remove();\n  headCord = [0, 0];\n  snakeBody = [];\n  score = 0;\n  speed = 200;\n  bombCount = 0;\n  snakeDirection = 'ArrowRight';\n  snakeBody.push(headCord);\n  d3.select('#game-space').append('svg').attr('id', 'board').attr('width', boardWidth).attr('height', boardHeight).append('rect').attr('class', 'snake head').attr(\"id\", \"segment\" + (snakeBody.length - 1)).attr('width', segmentDim).attr('height', segmentDim).attr('x', headCord[0]).attr('y', headCord[1]).attr(\"ry\", segmentRadius).attr(\"rx\", segmentRadius).attr('fill', 'red'); // do this with d3\n\n  d3.select('#score-count').text(score);\n  spawnFood();\n  gameTick();\n}\n\nfunction randomBoardCord() {\n  let x = Math.round(Math.random() * boardWidth / segmentDim) * segmentDim - segmentDim;\n  let y = Math.round(Math.random() * boardHeight / segmentDim) * segmentDim - segmentDim; // keep food on map\n\n  if (x > boardWidth) {\n    x = boardWidth - segmentDim;\n  }\n\n  if (x < 0) {\n    x = 0;\n  }\n\n  if (y > boardHeight) {\n    y = boardHeight - segmentDim;\n  }\n\n  if (y < 0) {\n    y = 0;\n  }\n\n  return [x, y];\n}\n\nfunction spawnFood() {\n  foodCord = randomBoardCord();\n  d3.select('#board').append('rect').attr(\"id\", \"food\").attr(\"width\", segmentDim).attr(\"height\", segmentDim).attr(\"x\", foodCord[0]).attr(\"y\", foodCord[1]).attr(\"ry\", segmentRadius).attr(\"rx\", segmentRadius).attr(\"fill\", \"limegreen\").style(\"opacity\", 0).transition().duration(1000).style(\"opacity\", 1);\n  foodOnBoard = true;\n}\n\nfunction spawnBomb() {\n  bombCord = randomBoardCord();\n  bombCount = 5;\n  d3.select('#board').append('rect').attr(\"id\", \"bomb\").attr(\"width\", segmentDim).attr(\"height\", segmentDim).attr(\"x\", bombCord[0]).attr(\"y\", bombCord[1]).attr(\"ry\", segmentRadius).attr(\"rx\", segmentRadius).attr(\"fill\", \"orange\").style(\"opacity\", 0).attr(\"stroke\", \"red\").transition().duration(1000).style(\"opacity\", 1);\n  d3.select('#board').append('text').attr('id', 'bomb-text').text(bombCount).style('fill', 'black').style('font-size', '65%').attr(\"transform\", \"translate(\" + (bombCord[0] + segmentDim / 4) + \",\" + (bombCord[1] + segmentDim - 1) + \")\");\n  liveBomb = true;\n}\n\nfunction moveSnake(index, cord) {\n  d3.select('#segment' + index).attr(\"x\", cord[0]).attr(\"y\", cord[1]);\n\n  if (+index !== snakeBody.length - 1) {\n    let nextIdx = index + 1;\n    let oldCord = snakeBody[index];\n    moveSnake(nextIdx, oldCord);\n  }\n\n  snakeBody[index] = [cord[0], cord[1]];\n}\n\nfunction gameLost() {\n  clearTimeout(gameTicker);\n  console.warn('Game over.'); // remove old stuff and show game over\n\n  d3.select('#food').transition().duration(1000).style(\"opacity\", 0).remove();\n  d3.selectAll(\".snake\").transition().duration(1000).style(\"opacity\", 0).remove();\n  d3.select('#bomb-text').remove();\n  d3.select('#bomb').transition().duration(1000).style(\"opacity\", 0).remove();\n  d3.select('#game-space').append('h3').text('GAME OVER').attr('id', 'end-text').style(\"opacity\", 0).transition().duration(1000).style(\"opacity\", 1);\n  d3.select('#start-game').style(\"display\", \"block\");\n}\n\nfunction bombGoesBoom() {\n  let colorScale = d3.scaleLinear().domain([0, bombRadius]).range(['red', 'yellow']);\n  let explosionArea = [];\n\n  for (let i = 1; i <= bombRadius; i++) {\n    let start = bombCord;\n\n    for (let xDim = -i; xDim <= i; xDim++) {\n      for (let yDim = -i; yDim <= i; yDim++) {\n        let newX = start[0] + xDim * segmentDim;\n        let newY = start[1] + yDim * segmentDim;\n        let newCord = [newX, newY];\n\n        if (!explosionArea.includes(newCord)) {\n          explosionArea.push(newCord);\n        }\n      }\n    }\n  }\n\n  for (let block of explosionArea) {\n    // distance in block units\n    let distance = distanceBetweenPoints(bombCord, block) / segmentDim;\n    d3.select('#board').append('rect').attr(\"class\", \"boom\").attr(\"width\", segmentDim).attr(\"height\", segmentDim).attr(\"x\", block[0]).attr(\"y\", block[1]).attr(\"ry\", segmentRadius).attr(\"rx\", segmentRadius).attr(\"fill\", colorScale(distance)).style(\"opacity\", 1).attr(\"stroke\", \"red\").transition().duration(1500).style(\"opacity\", 0).attr(\"fill\", \"blue\").attr(\"width\", 1).attr(\"height\", 1).remove();\n  }\n\n  d3.select('#bomb-text').remove();\n  d3.select('#bomb').transition().duration(1500).style(\"opacity\", 0).remove();\n  bombCount = 0;\n  liveBomb = false;\n  isHeadInExplosion();\n} // function distanceBetweenPoints (pointA, pointB) {\n//   let x0 = pointA[0];\n//   let x1 = pointB[0];\n//   let y0 = pointA[1];\n//   let y1 = pointB[1];\n//   let x = Math.pow((x1-x0), 2);\n//   let y = Math.pow((y1-y0), 2)\n//   let distance = Math.pow((x + y), 0.5);\n//   return distance;\n// }\n\n\nfunction isHeadInExplosion() {\n  let explosionXRange = [bombCord[0] - segmentDim * bombRadius, bombCord[0] + segmentDim * bombRadius];\n  let explosionYRange = [bombCord[1] - segmentDim * bombRadius, bombCord[1] + segmentDim * bombRadius];\n  let detectX = headCord[0] >= explosionXRange[0] && headCord[0] <= explosionXRange[1];\n  let detectY = headCord[1] >= explosionYRange[0] && headCord[1] <= explosionYRange[1];\n\n  if (detectX && detectY) {\n    console.log(\"Ouch, killed by a bomb...\");\n    gameLost();\n  }\n}\n\nfunction gameTick() {\n  count++;\n\n  if (snakeDirection === 'ArrowLeft') {\n    headCord[0] = headCord[0] - segmentDim;\n  } else if (snakeDirection === 'ArrowUp') {\n    headCord[1] = headCord[1] - segmentDim;\n  } else if (snakeDirection === 'ArrowRight') {\n    headCord[0] = headCord[0] + segmentDim;\n  } else if (snakeDirection === 'ArrowDown') {\n    headCord[1] = headCord[1] + segmentDim;\n  } //headCord = [0,0]\n\n\n  snakeTail = [snakeBody[snakeBody.length - 1][0], snakeBody[snakeBody.length - 1][1]];\n  moveSnake(0, headCord);\n\n  if (foodCord.length > 0) {\n    if (foodCord[0] === headCord[0] && foodCord[1] === headCord[1]) {\n      console.warn('FOOD EATEN!!!');\n      score++;\n\n      if (speed > 100) {\n        speed = speed - 25;\n      }\n\n      d3.select(\"#score-count\").text(score);\n      d3.select('#food').remove();\n      foodOnBoard = false;\n      snakeBody.push(snakeTail);\n      d3.select('#board').append('rect').attr(\"class\", \"snake\").attr(\"id\", \"segment\" + (snakeBody.length - 1)).attr(\"width\", segmentDim).attr(\"height\", segmentDim).attr(\"x\", snakeTail[0]).attr(\"y\", snakeTail[1]).attr(\"ry\", segmentRadius).attr(\"rx\", segmentRadius).attr(\"fill\", \"purple\");\n    }\n  }\n\n  if (count % 5 === 0 && !foodOnBoard) {\n    spawnFood();\n  } // bomb tick\n\n\n  if (liveBomb) {\n    console.log('This bomb is ticking...', bombCount); // count down in seconds\n\n    let slowCount = Math.round(1000 / speed);\n\n    if (+bombCount > 0 && count % slowCount === 1) {\n      bombCount = bombCount - 1;\n      d3.select('#bomb-text').text(bombCount);\n    } else if (bombCount <= 0) {\n      // boom\n      console.log(\"Boom!\");\n      bombGoesBoom();\n    }\n  } // spawn bomb\n\n\n  if (score > 0 && count % 10 === 0 && !liveBomb) {\n    spawnBomb();\n  } // losing conditions\n\n\n  if (headCord[0] >= boardWidth || headCord[0] < 0 // off the sides \n  || headCord[1] < 0 || headCord[1] >= boardHeight) {\n    // off the top or bottom\n    console.log('Snakes out of the box!');\n    gameLost();\n    return;\n  }\n\n  for (let segment of snakeBody) {\n    if (snakeBody.indexOf(segment) === 0) {\n      continue;\n    }\n\n    if (headCord[0] === segment[0] && headCord[1] === segment[1]) {\n      console.log('You bit your own tail...');\n      gameLost();\n      return;\n    }\n  }\n\n  gameTicker = setTimeout(function () {\n    gameTick();\n  }, speed);\n}","map":{"version":3,"sources":["/Users/williamvennard/my-app/src/SnakeApp.js"],"names":["d3","SnakeGame","constructor","playing","count","foodCord","headCord","snakeBody","foodOnBoard","score","speed","snakeTail","snakeDirection","lastSnakeDirection","segmentDim","boardWidth","boardHeight","segmentRadius","initGame","select","style","remove","bombCount","push","append","attr","length","text","spawnFood","gameTick","randomBoardCord","segDim","x","Math","round","random","y","transition","duration","moveSnake","index","cord","nextIdx","oldCord","gameLost","clearTimeout","gameTicker","console","log","selectAll","warn","snakeBombs","SnakeBombs","liveBomb","slowCount","bombGoesBoom","spawnBomb","segment","indexOf","that","setTimeout","bombCord","explosionRadius","colorScale","scaleLinear","domain","bombRadius","range","explosionArea","i","start","xDim","yDim","newX","newY","newCord","includes","block","distance","distanceBetweenPoints","isHeadInExplosion","bombR","explosionXRange","explosionYRange","detectX","detectY","pointA","pointB","x0","x1","y0","y1","pow","startSnakeGame","document","addEventListener","event","key","preventDefault"],"mappings":"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","sourcesContent":["import * as d3 from \"d3\";\n\nclass SnakeGame {\n  constructor() {\n    this.playing = false;\n    this.count = 0;\n    this.foodCord = [];\n    this.headCord = [];\n    this.snakeBody = [];\n    this.foodOnBoard = false;\n    this.score = 0;\n    this.speed = 200;\n    this.snakeTail = [];\n    this.snakeDirection = 'ArrowRight';\n    this.lastSnakeDirection = '';\n\n    // this.board = {\n    //   width: 300,\n    //   height: 300\n    // }\n\n    const segmentDim = 10;\n    const boardWidth = 300;\n    const boardHeight = 300;\n    const segmentRadius = 5;\n  }\n\n  // Might be a better way to do this.\n  // put into another class and simply reset?\n  initGame() {\n    d3.select('#score').style(\"display\", \"block\")\n    d3.select('#start-game').style(\"display\", \"none\")\n    d3.select('#board').remove();\n    d3.select('#end-text').remove();\n    this.headCord = [0,0];\n    this.snakeBody = [];\n    this.score = 0;\n    this.speed = 200;\n    this.bombCount = 0\n    this.snakeDirection = 'ArrowRight';\n    this.snakeBody.push(this.headCord);\n    this.playing = true;\n\n    d3.select('#game-space')\n      .append('svg')\n      .attr('id', 'board')\n      .attr('width', this.boardWidth)\n      .attr('height', this.boardHeight)\n      .append('rect')\n      .attr('class', 'snake head')\n      .attr(\"id\", \"segment\" + (this.snakeBody.length-1))\n      .attr('width', this.segmentDim)\n      .attr('height', this.segmentDim)\n      .attr('x', this.headCord[0])\n      .attr('y', this.headCord[1])\n      .attr(\"ry\", this.segmentRadius)\n      .attr(\"rx\", this.segmentRadius)\n      .attr('fill', 'red')\n\n    // do this with d3\n    d3.select('#score-count')\n      .text(this.score)\n\n    this.spawnFood();\n    this.gameTick();\n  }\n\n  randomBoardCord() {\n    let segDim = this.segmentDim;\n    let x = (Math.round(Math.random()*this.boardWidth/segDim)*segDim) - segDim;\n    let y = (Math.round(Math.random()*this.boardHeight/segDim)*segDim) - segDim;\n    // keep food on map\n    if (x > this.boardWidth) { x = this.boardWidth - segDim}\n    if (x < 0) { x = 0 }\n    if (y > this.boardHeight) {y = this.boardHeight - segDim}\n    if (y < 0) { y = 0 }\n\n    return [x,y];\n  }\n\n  spawnFood() {\n    this.foodCord = this.randomBoardCord()\n\n    d3.select('#board').append('rect')\n      .attr(\"id\", \"food\")\n      .attr(\"width\", this.segmentDim)\n      .attr(\"height\", this.segmentDim)\n      .attr(\"x\", this.foodCord[0])\n      .attr(\"y\", this.foodCord[1])\n      .attr(\"ry\", this.segmentRadius)\n      .attr(\"rx\", this.segmentRadius)\n      .attr(\"fill\", \"limegreen\")\n      .style(\"opacity\", 0)\n      .transition()\n      .duration(1000)\n      .style(\"opacity\", 1)\n\n    this.foodOnBoard = true;\n  }\n\n  moveSnake(index, cord) {\n    d3.select('#segment' + index)\n      .attr(\"x\", cord[0])\n      .attr(\"y\", cord[1]);\n\n    if (+index !== this.snakeBody.length-1) {\n      let nextIdx = index + 1;\n      let oldCord = this.snakeBody[index];\n      moveSnake(nextIdx, oldCord)\n    }\n    this.snakeBody[index] = [cord[0], cord[1]];\n  }\n\n  gameLost() {\n    clearTimeout(gameTicker);\n    console.log('Game over.')\n    if(!this.playing) { return; }\n    this.playing = false;\n\n    // remove old stuff and show game over\n    d3.select('#food').transition()\n      .duration(1000)\n      .style(\"opacity\", 0)\n      .remove();\n\n    d3.selectAll(\".snake\").transition()\n      .duration(1000)\n      .style(\"opacity\", 0)\n      .remove();\n\n    d3.select('#bomb-text').remove();\n\n    d3.select('#bomb')\n      .transition()\n      .duration(1000)\n      .style(\"opacity\", 0)\n      .remove();\n\n    d3.select('#end-text').remove();\n      \n    d3.select('#game-space')\n      .append('h3')\n      .text('GAME OVER')\n      .attr('id', 'end-text')\n      .style(\"opacity\", 0)\n      .transition()\n      .duration(1000)\n      .style(\"opacity\", 1)\n\n    d3.select('#start-game')\n      .style(\"display\", \"block\")\n      \n  }\n\n  gameTick() {\n    this.count++;\n    if(this.snakeDirection === 'ArrowLeft') {\n      this.headCord[0] = this.headCord[0] - this.segmentDim;\n    }else if(snakeDirection === 'ArrowUp') {\n      this.headCord[1] = this.headCord[1] - this.segmentDim;\n    }else if(snakeDirection === 'ArrowRight') {\n      this.headCord[0] = this.headCord[0] + this.segmentDim;\n    }else if(snakeDirection === 'ArrowDown') {\n      this.headCord[1] = this.headCord[1] + this.segmentDim;\n    }\n    //headCord = [0,0]\n    this.snakeTail = [this.snakeBody[this.snakeBody.length-1][0], this.snakeBody[this.snakeBody.length-1][1]];\n\n    moveSnake(0, this.headCord);\n\n    if (this.foodCord.length > 0) {\n      if(this.foodCord[0] === this.headCord[0] && this.foodCord[1] === this.headCord[1]) {\n        console.warn('FOOD EATEN!!!')\n        this.score++;\n        if (this.speed > 100) {\n          this.speed = this.speed-25;\n        }\n\n        d3.select(\"#score-count\")\n          .text(this.score)\n\n        d3.select('#food').remove();\n        this.foodOnBoard = false;\n\n        this.snakeBody.push(this.snakeTail)\n\n        d3.select('#board').append('rect')\n          .attr(\"class\", \"snake\")\n          .attr(\"id\", \"segment\" + (this.snakeBody.length-1))\n          .attr(\"width\", this.segmentDim)\n          .attr(\"height\", this.segmentDim)\n          .attr(\"x\", this.snakeTail[0])\n          .attr(\"y\", this.snakeTail[1])\n          .attr(\"ry\", this.segmentRadius)\n          .attr(\"rx\", this.segmentRadius)\n          .attr(\"fill\", \"purple\");\n      }\n    }\n\n    if(this.count%5 === 0 && !this.foodOnBoard) {\n      this.spawnFood();\n    }\n\n    // put bomb stuff in seperate function\n    let snakeBombs = new SnakeBombs();\n    console.warn(\"DEBUG DEBUG game tick: snakeBombs =\", snakeBombs)\n    // bomb tick\n    if (this.liveBomb) {\n      console.log('This bomb is ticking...', bombCount)\n      // count down in seconds\n      let slowCount = Math.round(1000/this.speed);\n      if (+this.bombCount > 0 && this.count%slowCount === 1) {\n        this.bombCount = this.bombCount - 1;\n        d3.select('#bomb-text')\n          .text(this.bombCount)\n      } else if (this.bombCount <= 0){\n        // boom\n        console.log(\"Boom!\")\n        this.bombGoesBoom();\n      }\n    }\n\n    // spawn bomb\n    if(this.score > 0 && this.count%10 === 0 && !this.liveBomb) {\n      this.spawnBomb();\n    }\n\n    // losing conditions\n    if(this.headCord[0] >= this.boardWidth || this.headCord[0] < 0 // off the sides \n      || this.headCord[1] < 0 || this.headCord[1] >= this.boardHeight) { // off the top or bottom\n      console.log('Snakes out of the box!')\n      this.gameLost();\n      return\n    }\n    for (let segment of this.snakeBody) {\n      if (this.snakeBody.indexOf(segment) === 0) {\n        continue\n      }\n      if(this.headCord[0] === segment[0] && this.headCord[1] === segment[1]) {\n        console.log('You bit your own tail...')\n        this.gameLost()\n        return\n      }\n    }\n\n    let that = this;\n    gameTicker = setTimeout(function() {\n      that.gameTick()\n    }, that.speed);\n  }\n\n\n}\n\nclass SnakeBombs extends SnakeGame {\n  constructor() {\n    this.bombCord = [];\n    this.liveBomb = false;\n    this.bombCount = 0;\n    this.explosionRadius = 2;\n  }\n\n  spawnBomb() {\n    this.bombCord = randomBoardCord();\n    this.bombCount = 5;\n    d3.select('#board').append('rect')\n      .attr(\"id\", \"bomb\")\n      .attr(\"width\", this.segmentDim)\n      .attr(\"height\", this.segmentDim)\n      .attr(\"x\", this.bombCord[0])\n      .attr(\"y\", this.bombCord[1])\n      .attr(\"ry\", this.segmentRadius)\n      .attr(\"rx\", this.segmentRadius)\n      .attr(\"fill\", \"orange\")\n      .style(\"opacity\", 0)\n      .attr(\"stroke\", \"red\")\n      .transition()\n      .duration(1000)\n      .style(\"opacity\", 1)\n\n    d3.select('#board').append('text')\n      .attr('id', 'bomb-text')\n      .text(this.bombCount)\n      .style('fill', 'black')\n      .style('font-size', '65%')\n      .attr(\"transform\", \"translate(\"+(this.bombCord[0]+this.segmentDim/4)+\",\"+(this.bombCord[1]+this.segmentDim-1)+\")\");\n\n    this.liveBomb = true;\n  }\n\n  bombGoesBoom () {\n    let colorScale = d3.scaleLinear()\n      .domain([0, this.bombRadius])\n      .range(['red', 'yellow']);\n\n    let explosionArea = [];\n    for(let i = 1; i <= this.bombRadius; i++) {\n      let start = this.bombCord;\n      for(let xDim = -i; xDim <= i; xDim++) {\n        for(let yDim = -i; yDim <= i; yDim++) {\n          let newX = start[0] + (xDim*this.segmentDim)\n          let newY = start[1] + (yDim*this.segmentDim)\n          let newCord = [newX, newY];\n          if(!explosionArea.includes(newCord)) {\n            explosionArea.push(newCord)\n          }\n        }\n      }\n    }\n\n    for(let block of explosionArea) {\n      // distance in block units\n      let distance = distanceBetweenPoints(this.bombCord, block)/segmentDim\n\n      d3.select('#board').append('rect')\n        .attr(\"class\", \"boom\")\n        .attr(\"width\", this.segmentDim)\n        .attr(\"height\", this.segmentDim)\n        .attr(\"x\", block[0])\n        .attr(\"y\", block[1])\n        .attr(\"ry\", this.segmentRadius)\n        .attr(\"rx\", this.segmentRadius)\n        .attr(\"fill\", colorScale(distance))\n        .style(\"opacity\", 1)\n        .attr(\"stroke\", \"red\")\n        .transition()\n        .duration(1500)\n        .style(\"opacity\", 0)\n        .attr(\"fill\", \"blue\")\n        .attr(\"width\", 1)\n        .attr(\"height\", 1)\n        .remove();\n    }\n\n    d3.select('#bomb-text').remove();\n    d3.select('#bomb')\n      .transition()\n      .duration(1500)\n      .style(\"opacity\", 0)\n      .remove();\n\n    this.bombCount = 0;\n    this.liveBomb = false;\n\n    this.isHeadInExplosion()\n  }\n\n  isHeadInExplosion() {\n    let bombR = this.bombRadius;\n    let segDim = this.segmentDim;\n    let explosionXRange = [this.bombCord[0]-segDim*bombR, this.bombCord[0]+segDim*bombR];\n    let explosionYRange = [this.bombCord[1]-segDim*bombR, this.bombCord[1]+segDim*bombR];\n    let detectX = this.headCord[0] >= explosionXRange[0] && this.headCord[0] <= explosionXRange[1];\n    let detectY = this.headCord[1] >= explosionYRange[0] && this.headCord[1] <= explosionYRange[1];\n    if (detectX && detectY) {\n      console.log(\"Ouch, killed by a bomb...\")\n      this.gameLost();\n    }\n  }\n  \n\n}\n\nfunction distanceBetweenPoints (pointA, pointB) {\n  let x0 = pointA[0];\n  let x1 = pointB[0];\n  let y0 = pointA[1];\n  let y1 = pointB[1];\n  let x = Math.pow((x1-x0), 2);\n  let y = Math.pow((y1-y0), 2)\n  let distance = Math.pow((x + y), 0.5);\n\n  return distance;\n}\n\n// snake\nlet gameTicker;\nlet count = 0;\nconst segmentDim = 10;\nconst boardWidth = 300;\nconst boardHeight = 300;\nconst segmentRadius = 5;\nlet foodCord = [];\n\nlet headCord = [];\nlet snakeBody = [];\nlet foodOnBoard = false;\nlet score = 0;\nlet speed = 200;\nlet snakeTail = [];\nlet snakeDirection = 'ArrowRight';\nlet lastSnakeDirection = '';\n// bomb stuff\nlet bombCord = [];\nlet liveBomb = false;\nlet bombCount = 0;\nlet bombRadius = 3;\n\nexport function startSnakeGame() {\n    console.log('startSnakeGame: Start game!!')\n    initGame()\n}\n\ndocument.addEventListener('keydown', (event) => {\n  if(event.key === 'ArrowLeft' || event.key === 'ArrowUp' || event.key === 'ArrowRight' || event.key === 'ArrowDown') {\n    event.preventDefault();\n    if (snakeDirection === 'ArrowLeft' && event.key === 'ArrowRight') { return }\n    if (snakeDirection === 'ArrowRight' && event.key === 'ArrowLeft') { return }\n    if (snakeDirection === 'ArrowUp' && event.key === 'ArrowDown') { return }\n    if (snakeDirection === 'ArrowDown' && event.key === 'ArrowUp') { return }\n    snakeDirection = event.key;\n  }\n});\n\nfunction initGame() {\n  d3.select('#score')\n      .style(\"display\", \"block\")\n  d3.select('#start-game')\n      .style(\"display\", \"none\")\n  d3.select('#board').remove();\n  d3.select('#end-text').remove();\n  headCord = [0,0];\n  snakeBody = [];\n  score = 0;\n  speed = 200;\n  bombCount = 0\n  snakeDirection = 'ArrowRight';\n  snakeBody.push(headCord);\n\n  d3.select('#game-space')\n    .append('svg')\n    .attr('id', 'board')\n    .attr('width', boardWidth)\n    .attr('height', boardHeight)\n    .append('rect')\n    .attr('class', 'snake head')\n    .attr(\"id\", \"segment\" + (snakeBody.length-1))\n    .attr('width', segmentDim)\n    .attr('height', segmentDim)\n    .attr('x', headCord[0])\n    .attr('y', headCord[1])\n    .attr(\"ry\", segmentRadius)\n    .attr(\"rx\", segmentRadius)\n    .attr('fill', 'red')\n\n  // do this with d3\n  d3.select('#score-count')\n    .text(score)\n\n  spawnFood();\n  gameTick();\n}\n\nfunction randomBoardCord() {\n  let x = (Math.round(Math.random()*boardWidth/segmentDim)*segmentDim) - segmentDim;\n  let y = (Math.round(Math.random()*boardHeight/segmentDim)*segmentDim) - segmentDim;\n  // keep food on map\n  if (x > boardWidth) { x = boardWidth - segmentDim}\n  if (x < 0) { x = 0 }\n  if (y > boardHeight) {y = boardHeight - segmentDim}\n  if (y < 0) { y = 0 }\n\n  return [x,y];\n}\n\nfunction spawnFood() {\n  foodCord = randomBoardCord()\n\n  d3.select('#board').append('rect')\n    .attr(\"id\", \"food\")\n    .attr(\"width\", segmentDim)\n    .attr(\"height\", segmentDim)\n    .attr(\"x\", foodCord[0])\n    .attr(\"y\", foodCord[1])\n    .attr(\"ry\", segmentRadius)\n    .attr(\"rx\", segmentRadius)\n    .attr(\"fill\", \"limegreen\")\n    .style(\"opacity\", 0)\n    .transition()\n    .duration(1000)\n    .style(\"opacity\", 1)\n\n  foodOnBoard = true;\n}\n\nfunction spawnBomb() {\n  bombCord = randomBoardCord();\n  bombCount = 5;\n  d3.select('#board').append('rect')\n    .attr(\"id\", \"bomb\")\n    .attr(\"width\", segmentDim)\n    .attr(\"height\", segmentDim)\n    .attr(\"x\", bombCord[0])\n    .attr(\"y\", bombCord[1])\n    .attr(\"ry\", segmentRadius)\n    .attr(\"rx\", segmentRadius)\n    .attr(\"fill\", \"orange\")\n    .style(\"opacity\", 0)\n    .attr(\"stroke\", \"red\")\n    .transition()\n    .duration(1000)\n    .style(\"opacity\", 1)\n\n  d3.select('#board').append('text')\n    .attr('id', 'bomb-text')\n    .text(bombCount)\n    .style('fill', 'black')\n    .style('font-size', '65%')\n    .attr(\"transform\", \"translate(\"+(bombCord[0]+segmentDim/4)+\",\"+(bombCord[1]+segmentDim-1)+\")\");\n\n  liveBomb = true;\n}\n\nfunction moveSnake(index, cord) {\n  d3.select('#segment' + index)\n    .attr(\"x\", cord[0])\n    .attr(\"y\", cord[1]);\n\n  if (+index !== snakeBody.length-1) {\n    let nextIdx = index + 1;\n    let oldCord = snakeBody[index];\n    moveSnake(nextIdx, oldCord)\n  }\n  snakeBody[index] = [cord[0], cord[1]];\n}\n\nfunction gameLost() {\n  clearTimeout(gameTicker);\n  console.warn('Game over.')\n\n  // remove old stuff and show game over\n  d3.select('#food').transition()\n    .duration(1000)\n    .style(\"opacity\", 0)\n    .remove();\n\n  d3.selectAll(\".snake\").transition()\n    .duration(1000)\n    .style(\"opacity\", 0)\n    .remove();\n\n  d3.select('#bomb-text').remove();\n\n  d3.select('#bomb')\n    .transition()\n    .duration(1000)\n    .style(\"opacity\", 0)\n    .remove();\n\n  d3.select('#game-space')\n    .append('h3')\n    .text('GAME OVER')\n    .attr('id', 'end-text')\n    .style(\"opacity\", 0)\n    .transition()\n    .duration(1000)\n    .style(\"opacity\", 1)\n\n  d3.select('#start-game')\n    .style(\"display\", \"block\")\n    \n}\n\nfunction bombGoesBoom() {\n  let colorScale = d3.scaleLinear()\n    .domain([0, bombRadius])\n    .range(['red', 'yellow']);\n\n  let explosionArea = [];\n  for(let i = 1; i <= bombRadius; i++) {\n    let start = bombCord;\n    for(let xDim = -i; xDim <= i; xDim++) {\n      for(let yDim = -i; yDim <= i; yDim++) {\n        let newX = start[0] + (xDim*segmentDim)\n        let newY = start[1] + (yDim*segmentDim)\n        let newCord = [newX, newY];\n        if(!explosionArea.includes(newCord)) {\n          explosionArea.push(newCord)\n        }\n      }\n    }\n  }\n\n  for(let block of explosionArea) {\n    // distance in block units\n    let distance = distanceBetweenPoints (bombCord, block)/segmentDim\n\n    d3.select('#board').append('rect')\n      .attr(\"class\", \"boom\")\n      .attr(\"width\", segmentDim)\n      .attr(\"height\", segmentDim)\n      .attr(\"x\", block[0])\n      .attr(\"y\", block[1])\n      .attr(\"ry\", segmentRadius)\n      .attr(\"rx\", segmentRadius)\n      .attr(\"fill\", colorScale(distance))\n      .style(\"opacity\", 1)\n      .attr(\"stroke\", \"red\")\n      .transition()\n      .duration(1500)\n      .style(\"opacity\", 0)\n      .attr(\"fill\", \"blue\")\n      .attr(\"width\", 1)\n      .attr(\"height\", 1)\n      .remove();\n  }\n\n  d3.select('#bomb-text').remove();\n  d3.select('#bomb')\n    .transition()\n    .duration(1500)\n    .style(\"opacity\", 0)\n    .remove();\n\n  bombCount = 0;\n  liveBomb = false;\n\n  isHeadInExplosion()\n}\n\n// function distanceBetweenPoints (pointA, pointB) {\n//   let x0 = pointA[0];\n//   let x1 = pointB[0];\n//   let y0 = pointA[1];\n//   let y1 = pointB[1];\n//   let x = Math.pow((x1-x0), 2);\n//   let y = Math.pow((y1-y0), 2)\n//   let distance = Math.pow((x + y), 0.5);\n\n//   return distance;\n// }\n\nfunction isHeadInExplosion() {\n  let explosionXRange = [bombCord[0]-segmentDim*bombRadius, bombCord[0]+segmentDim*bombRadius];\n  let explosionYRange = [bombCord[1]-segmentDim*bombRadius, bombCord[1]+segmentDim*bombRadius];\n  let detectX = headCord[0] >= explosionXRange[0] && headCord[0] <= explosionXRange[1];\n  let detectY = headCord[1] >= explosionYRange[0] && headCord[1] <= explosionYRange[1];\n  if (detectX && detectY) {\n    console.log(\"Ouch, killed by a bomb...\")\n    gameLost();\n  }\n}\n\nfunction gameTick() {\n  count++;\n  if(snakeDirection === 'ArrowLeft') {\n    headCord[0] = headCord[0] - segmentDim;\n  }else if(snakeDirection === 'ArrowUp') {\n    headCord[1] = headCord[1] - segmentDim;\n  }else if(snakeDirection === 'ArrowRight') {\n    headCord[0] = headCord[0] + segmentDim;\n  }else if(snakeDirection === 'ArrowDown') {\n    headCord[1] = headCord[1] + segmentDim;\n  }\n  //headCord = [0,0]\n  snakeTail = [snakeBody[snakeBody.length-1][0], snakeBody[snakeBody.length-1][1]];\n  moveSnake(0, headCord);\n\n  if (foodCord.length > 0) {\n    if(foodCord[0] === headCord[0] && foodCord[1] === headCord[1]) {\n      console.warn('FOOD EATEN!!!')\n      score++;\n      if (speed > 100) {\n        speed = speed-25;\n      }\n\n      d3.select(\"#score-count\")\n        .text(score)\n\n      d3.select('#food').remove();\n      foodOnBoard = false;\n\n      snakeBody.push(snakeTail)\n\n      d3.select('#board').append('rect')\n        .attr(\"class\", \"snake\")\n        .attr(\"id\", \"segment\" + (snakeBody.length-1))\n        .attr(\"width\", segmentDim)\n        .attr(\"height\", segmentDim)\n        .attr(\"x\", snakeTail[0])\n        .attr(\"y\", snakeTail[1])\n        .attr(\"ry\", segmentRadius)\n        .attr(\"rx\", segmentRadius)\n        .attr(\"fill\", \"purple\");\n    }\n  }\n\n  if(count%5 === 0 && !foodOnBoard) {\n    spawnFood();\n  }\n\n  // bomb tick\n  if (liveBomb) {\n    console.log('This bomb is ticking...', bombCount)\n    // count down in seconds\n    let slowCount = Math.round(1000/speed);\n    if (+bombCount > 0 && count%slowCount === 1) {\n      bombCount = bombCount - 1;\n      d3.select('#bomb-text')\n        .text(bombCount)\n    } else if (bombCount <= 0){\n      // boom\n      console.log(\"Boom!\")\n      bombGoesBoom();\n    }\n  }\n\n  // spawn bomb\n  if(score > 0 && count%10 === 0 && !liveBomb) {\n    spawnBomb();\n  }\n\n  // losing conditions\n  if(headCord[0] >= boardWidth || headCord[0] < 0 // off the sides \n    || headCord[1] < 0 || headCord[1] >= boardHeight) { // off the top or bottom\n    console.log('Snakes out of the box!')\n    gameLost();\n    return\n  }\n  for (let segment of snakeBody) {\n    if (snakeBody.indexOf(segment) === 0) {\n      continue\n    }\n    if(headCord[0] === segment[0] && headCord[1] === segment[1]) {\n      console.log('You bit your own tail...')\n      gameLost()\n      return\n    }\n  }\n\n  gameTicker = setTimeout(function() {\n    gameTick()\n  }, speed);\n}\n"]},"metadata":{},"sourceType":"module"}